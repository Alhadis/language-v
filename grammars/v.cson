name: "V"
scopeName: "source.v"
fileTypes: [
	"v"
	"vh"
	"vsh"
	"vv"
]
firstLineMatch: """(?x)

	# Interpreter directive
	^\\#!.*(?:\\s|\\/|(?<=!)\\b)
		(?:vsh|v\\s+run)
	(?:$|\\s)

	|

	# Modelines
	(?i:
		# Emacs
		-\\*-(?:\\s*(?=[^:;\\s]+\\s*-\\*-)|(?:.*?[;\\s]|(?<=-\\*-))mode\\s*:\\s*)
			(?:vlang|v)
		(?=[\\s;]|(?<![-*])-\\*-).*?-\\*-
		
		|
		
		# Vim
		(?:(?:\\s|^)vi(?:m[<=>]?\\d+|m)?|\\sex)(?=:(?=\\s*set?\\s[^\\n:]+:)|:(?!\\s* set?\\s))
		(?:(?:\\s|\\s*:\\s*)\\w*(?:\\s*=(?:[^\\n\\\\\\s]|\\\\.)*)?)*[\\s:]
		(?:filetype|ft|syntax)\\s*=
			(?:vlang|v)
		(?=\\s|:|$)
	)
"""
patterns: [{
	# Interpreter directive
	name:  "comment.line.number-sign.hashbang.v"
	begin: "\\A#!"
	end:   "$"
	beginCaptures:
		0: name: "punctuation.definition.comment.v"
}, include: "#main"]

repository:
	main:
		patterns: [
			{include: "#comment"}
			{include: "#function"}
			{include: "#variable"}
			
			# Fallback highlighting for unexpected tokens
			{include: "#string"}
			{include: "#type"}
			{include: "#brackets"}
			{include: "#comma"}
		]


	# Anything that's accepted inside `fn foo(…)`; e.g., `mut names ...[]string`
	arg:
		name:  "meta.parameter.v"
		begin: "(?:(mut)\\s+)?(?!\\d|_\\b)(\\w+)\\b"
		end:   "(?!\\d|\\G)(?<=\\w)\\b|(?=\\s*(?!/[/*]|\\.{3})[^\\[\\w\\s])"
		beginCaptures:
			1: name: "storage.modifier.mutable.v"
			2: name: "variable.parameter.function.v"
		patterns: [{
			# Ellipsis/“splat” operator, used to implement variadic functions
			name: "keyword.operator.range.ellipsis.splat.spread.rest.v"
			match: "\\.{3}"
		}, include: "#types"]


	# Argument list, surrounded by parentheses
	args:
		name:  "meta.arguments.v"
		begin: "\\("
		end:   "\\)"
		beginCaptures: 0: patterns: [include: "#brackets"]
		endCaptures:   0: patterns: [include: "#brackets"]
		patterns: [
			{include: "#comment"}
			{include: "#arg"}
			{include: "#comma"}
		]


	# Bracket characters
	brackets:
		patterns: [
			{match: "\\{", name: "punctuation.definition.bracket.curly.brace.begin.v"}
			{match: "\\}", name: "punctuation.definition.bracket.curly.brace.end.v"}
			{match: "\\[", name: "punctuation.definition.bracket.square.begin.v"}
			{match: "\\]", name: "punctuation.definition.bracket.square.end.v"}
			{match: "\\(", name: "punctuation.definition.bracket.round.parenthesis.begin.v"}
			{match: "\\)", name: "punctuation.definition.bracket.round.parenthesis.end.v"}
			{match: "<",   name: "punctuation.definition.bracket.angle.begin.v"}
			{match: ">",   name: "punctuation.definition.bracket.angle.end.v"}
		]


	# You know what this is
	comma:
		name: "punctuation.separator.delimiter.list.comma.v"
		match: ","


	# Comments, both single- and multi-line forms
	comment:
		patterns: [
			{include: "#commentLine"}
			{include: "#commentBlock"}
		]
	
	# Single-line comment
	commentLine:
		name:  "comment.line.double-slash.v"
		begin: "//"
		end:   "$"
		beginCaptures:
			0: name: "punctuation.definition.comment.v"

	# Multiline (nestable) comment
	commentBlock:
		name:  "comment.block.v"
		begin: "/\\*"
		end:   "\\*/"
		beginCaptures: 0: name: "punctuation.definition.comment.begin.v"
		endCaptures:   0: name: "punctuation.definition.comment.end.v"
		patterns: [include: "#commentBlock"]


	# Function declaration
	function:
		name:  "meta.function.v"
		begin: "(?<![-$])\\b(?:(pub)\\s+)?(fn)(?=\\s|$|\\(|/[/*])"
		end:   "(?!\\G|(?={))"
		beginCaptures:
			1: name: "storage.modifier.public.v"
			2: name: "storage.type.function.v"
		patterns: [{
			name:  "meta.function-header.v"
			begin: "\\G"
			end:   "(?={)"
			patterns: [include: "#functionHeader"]
		},{
			name:  "meta.function-body.v"
			begin: "{"
			end:   "}"
			beginCaptures: 0: patterns: [include: "#brackets"]
			endCaptures:   0: patterns: [include: "#brackets"]
			patterns: [include: "#main"]
		}]


	# fn foo(arg type)
	functionHeader:
		patterns: [{
			# Skip empty lines
			begin: "\\G(?=[ \\t]*(?:$|/[/*]))"
			end:   "(?=\\S)(?!/[/*])"
			patterns: [include: "#comment"]
		},{
			# Receiver argument (for methods)
			name:  "meta.receiver.v"
			begin: "(?=\\()"
			end:   "(?<=\\))"
			patterns: [include: "#args"]
		},{
			# Function name
			begin: "\\w+"
			end:   "(?={)"
			beginCaptures:
				0: name: "entity.name.function.v"
			patterns: [{
				# Argument list
				name: "meta.parameters.v"
				begin: "(?=\\()"
				end:   "(?<=\\))"
				patterns: [include: "#args"]
			},{
				# Return type
				name:  "meta.return-type.v"
				begin: "(?<=\\))"
				end:   "(?={)|(?<=\\))(?!\\G)"
				patterns: [{
					# Multiple return values: fn foo() (first, second) {…}
					begin: "\\("
					end:   "\\)"
					beginCaptures: 0: patterns: [include: "#brackets"]
					endCaptures:   0: patterns: [include: "#brackets"]
					patterns: [include: "#types"]
				}, include: "#types"]
			}, include: "#comment"]
		}]


	# "Quoted string" or rune (character literal)
	string:
		patterns: [{
			# r'Raw\nstring'
			name:  "string.quoted.single.raw.v"
			begin: "(r)(')"
			end:   "'"
			beginCaptures:
				1: name: "keyword.operator.raw-string.v"
				2: name: "punctuation.definition.string.begin.v"
			endCaptures:
				0: name: "punctuation.definition.string.end.v"
		},{
			# r"Raw\nstring"
			name:  "string.quoted.double.raw.v"
			begin: '(r)(")'
			end:   '"'
			beginCaptures:
				1: name: "keyword.operator.raw-string.v"
				2: name: "punctuation.definition.string.begin.v"
			endCaptures:
				0: name: "punctuation.definition.string.end.v"
		},{
			# 'Single-quoted'
			name:  "string.quoted.single.v"
			begin: "'"
			end:   "'"
			beginCaptures: 0: name: "punctuation.definition.string.begin.v"
			endCaptures:   0: name: "punctuation.definition.string.end.v"
			patterns: [include: "#stringInnards"]
		},{
			# "Double-quoted"
			name:  "string.quoted.double.v"
			begin: '"'
			end:   '"'
			beginCaptures: 0: name: "punctuation.definition.string.begin.v"
			endCaptures:   0: name: "punctuation.definition.string.end.v"
			patterns: [include: "#stringInnards"]
		},{
			# Rune: `😂`
			name:  "string.quoted.single.rune.v"
			begin: "`"
			end:   "`"
			beginCaptures: 0: name: "punctuation.definition.string.begin.v"
			endCaptures:   0: name: "punctuation.definition.string.end.v"
		}]

	# Patterns matched inside a non-raw (cooked?) string
	stringInnards:
		patterns: [
			{include: "#escape"}
			{include: "#stringInterpolation"}
		]


	# Variable interpolation: "$foo ${bar}"
	stringInterpolation:
		patterns: [{
			# Unbracketed: "$foo $struct.field"
			name:  "meta.interpolation.simple.v"
			match: "(\\$)(\\w+(?:\\.\\w+)*)"
			captures:
				1: name: "punctuation.definition.variable.v"
				2: patterns: [include: "#variableRef"]
		},{
			# Bracketed: "${foo.bar > 32}"
			name:  "meta.embedded.section.interpolation.complex.v"
			begin: "\\${"
			end:   "}"
			beginCaptures: 0: name: "punctuation.section.embedded.begin.v"
			endCaptures:   0: name: "punctuation.section.embedded.end.v"
			patterns: [
				{include: "#variableRef"}
				{include: "#main"}
			]
		}]
		


	# Escaped string characters
	escape:
		patterns: [
			{include: "#escapedCharacter"}
			{include: "#escapedNewline"}
		]

	# C-like escape sequences
	escapedCharacter:
		patterns: [{
			# C-like, single-character escapes
			name: "constant.character.escape.v"
			match: "(\\\\)[abefnrtv'\"?\\\\]"
			captures:
				1: name: "punctuation.definition.escape.v"
		},{
			# Codepoint, octal
			name:  "constant.character.escape.codepoint.octal.oct.v"
			match: "(\\\\)[0-7]{3}"
			captures:
				1: name: "punctuation.definition.escape.v"
		},{
			# Codepoint, hexadecimal
			name:  "constant.character.escape.codepoint.hexadecimal.hex.v"
			match: "\\\\(?:x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})"
			captures: 0: patterns: [{
				name: "punctuation.definition.escape.v"
				match: "\\\\[xuU]"
			}]
		},{
			# Unrecognised escape sequence
			name:  "constant.character.escape.other.unknown.v"
			match: "(\\\\)."
			captures:
				1: name: "punctuation.definition.escape.v"
		}]
	
	
	# Line continuation
	escapedNewline:
		name:  "constant.character.escape.newline.line-continuation.v"
		begin: "(\\\\)$\\s*+"
		end:   "^"
		beginCaptures:
			1: name: "punctuation.definition.escape.v"



	# Type name, sans modifiers or array indicators
	type:
		patterns: [{
			# Predefined types
			name: "support.type.${1:/downcase}.v"
			match: "(?x) \\b
				( any
				| any_float
				| any_int
				| bool
				| byte
				| byteptr
				| charptr
				| f(?:32|64)
				| [iu](?:8|16|32|64|128)
				| int
				| rune
				| size_t
				| string
				| voidptr
				) \\b"
		},{
			# User-defined
			name: "entity.name.type.v"
			match: "(?!\\d)(\\w+)"
		}]
			


	# Anywhere type annotations are expected/legal
	types:
		patterns: [
			{include: "#comment"}
			{include: "#type"}
			{include: "#comma"}
			
			# Array indicator: `list []string`, `table [][]string`
			name: "punctuation.definition.array-type.v"
			match: "\\[\\]"
			captures:
				0: patterns: [include: "#brackets"]
		]


	# name := value
	variable:
		name:  "meta.variable.declaration.v"
		begin: "(?!\\d|_)(\\w+)\\s*(:=)"
		end:   "$"
		beginCaptures:
			1: name: "variable.assignment.v"
			2: name: "keyword.operator.assignment.declaration.v"
		patterns: [include: "#variableValue"]


	# Named reference to a variable
	variableRef:
		patterns: [{
			# Field accessor: `struct.field.subfield.subsubfield`
			name:  "meta.member-access.v"
			match: "(\\w+)((?:\\.\\w+)++\\.?)"
			captures:
				1: name: "variable.other.object.v"
				2: patterns: [
					{match: "\\.",         name: "punctuation.separator.dot.period.member.accessor.v"}
					{match: "\\w+(?=\\.)", name: "variable.other.object.property.v"}
					{match: "\\w+",        name: "variable.other.property.v"}
				]
		},{
			# Regular variable name
			name: "variable.other.v"
			match: "\\w+"
		}]


	# Right-hand side of a variable assignment/declaration
	variableValue:
		patterns: [
			{include: "#string"}
			{include: "#variableRef"}
		]
