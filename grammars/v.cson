name: "V"
scopeName: "source.v"
fileTypes: [
	"v"
	"vh"
	"vsh"
	"vv"
]
patterns: [include: "#main"]

repository:
	main:
		patterns: [
			{include: "#comment"}
			{include: "#function"}
		]


	# Anything that's accepted inside `fn foo(…)`; e.g., `mut names ...[]string`
	arg:
		name:  "meta.parameter.v"
		begin: "(?:(mut)\\s+)?(?!\\d|_\\b)(\\w+)\\b"
		end:   "(?!\\d|\\G)(?<=\\w)\\b|(?=\\s*(?!/[/*]|\\.{3})[^\\[\\w\\s])"
		beginCaptures:
			1: name: "storage.modifier.mutable.v"
			2: name: "variable.parameter.function.v"
		patterns: [{
			# Ellipsis/“splat” operator, used to implement variadic functions
			name: "keyword.operator.range.ellipsis.splat.spread.rest.v"
			match: "\\.{3}"
		}, include: "#types"]


	# Argument list, surrounded by parentheses
	args:
		name:  "meta.arguments.v"
		begin: "\\("
		end:   "\\)"
		beginCaptures: 0: patterns: [include: "#brackets"]
		endCaptures:   0: patterns: [include: "#brackets"]
		patterns: [
			{include: "#comment"}
			{include: "#arg"}
			{include: "#comma"}
		]


	# Bracket characters
	brackets:
		patterns: [
			{match: "\\{", name: "punctuation.definition.bracket.curly.brace.begin.v"}
			{match: "\\}", name: "punctuation.definition.bracket.curly.brace.end.v"}
			{match: "\\[", name: "punctuation.definition.bracket.square.begin.v"}
			{match: "\\]", name: "punctuation.definition.bracket.square.end.v"}
			{match: "\\(", name: "punctuation.definition.bracket.round.parenthesis.begin.v"}
			{match: "\\)", name: "punctuation.definition.bracket.round.parenthesis.end.v"}
			{match: "<",   name: "punctuation.definition.bracket.angle.begin.v"}
			{match: ">",   name: "punctuation.definition.bracket.angle.end.v"}
		]


	# You know what this is
	comma:
		name: "punctuation.separator.delimiter.list.comma.v"
		match: ","


	# Comments, both single- and multi-line forms
	comment:
		patterns: [
			{include: "#commentLine"}
			{include: "#commentBlock"}
		]
	
	# Single-line comment
	commentLine:
		name:  "comment.line.double-slash.v"
		begin: "//"
		end:   "$"
		beginCaptures:
			0: name: "punctuation.definition.comment.v"

	# Multiline (nestable) comment
	commentBlock:
		name:  "comment.block.v"
		begin: "/\\*"
		end:   "\\*/"
		beginCaptures: 0: name: "punctuation.definition.comment.begin.v"
		endCaptures:   0: name: "punctuation.definition.comment.end.v"
		patterns: [include: "#commentBlock"]


	# Function declaration
	function:
		name:  "meta.function.v"
		begin: "(?<![-$])\\b(?:(pub)\\s+)?(fn)(?=\\s|$|\\(|/[/*])"
		end:   "(?!\\G|(?={))"
		beginCaptures:
			1: name: "storage.modifier.public.v"
			2: name: "storage.type.function.v"
		patterns: [{
			name:  "meta.function-header.v"
			begin: "\\G"
			end:   "(?={)"
			patterns: [include: "#functionHeader"]
		},{
			name:  "meta.function-body.v"
			begin: "{"
			end:   "}"
			beginCaptures: 0: patterns: [include: "#brackets"]
			endCaptures:   0: patterns: [include: "#brackets"]
			patterns: [include: "#main"]
		}]


	# fn foo(arg type)
	functionHeader:
		patterns: [{
			# Skip empty lines
			begin: "\\G(?=[ \\t]*(?:$|/[/*]))"
			end:   "(?=\\S)(?!/[/*])"
			patterns: [include: "#comment"]
		},{
			# Receiver argument (for methods)
			name:  "meta.receiver.v"
			begin: "(?=\\()"
			end:   "(?<=\\))"
			patterns: [include: "#args"]
		},{
			# Function name
			begin: "\\w+"
			end:   "(?={)"
			beginCaptures:
				0: name: "entity.name.function.v"
			patterns: [{
				# Argument list
				name: "meta.parameters.v"
				begin: "(?=\\()"
				end:   "(?<=\\))"
				patterns: [include: "#args"]
			},{
				# Return type
				name:  "meta.return-type.v"
				begin: "(?<=\\))"
				end:   "(?={)|(?<=\\))(?!\\G)"
				patterns: [{
					# Multiple return values: fn foo() (first, second) {…}
					begin: "\\("
					end:   "\\)"
					beginCaptures: 0: patterns: [include: "#brackets"]
					endCaptures:   0: patterns: [include: "#brackets"]
					patterns: [include: "#types"]
				}, include: "#types"]
			}, include: "#comment"]
		}]


	# Type name, sans modifiers or array indicators
	type:
		name: "storage.type.${1:/downcase}.v"
		match: "(?!\\d)(\\w+)"


	# Anywhere type annotations are expected/legal
	types:
		patterns: [
			{include: "#comment"}
			{include: "#type"}
			{include: "#comma"}
			
			# Array indicator: `list []string`, `table [][]string`
			name: "punctuation.definition.array-type.v"
			match: "\\[\\]"
			captures:
				0: patterns: [include: "#brackets"]
		]
