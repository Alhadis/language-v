name: "V"
scopeName: "source.v"
fileTypes: [
	"v"
	"vh"
	"vsh"
	"vv"
]
firstLineMatch: """(?x)

	# Interpreter directive
	^\\#!.*(?:\\s|\\/|(?<=!)\\b)
		(?:vsh|v\\s+run)
	(?:$|\\s)

	|

	# Modelines
	(?i:
		# Emacs
		-\\*-(?:\\s*(?=[^:;\\s]+\\s*-\\*-)|(?:.*?[;\\s]|(?<=-\\*-))mode\\s*:\\s*)
			(?:vlang|v)
		(?=[\\s;]|(?<![-*])-\\*-).*?-\\*-
		
		|
		
		# Vim
		(?:(?:\\s|^)vi(?:m[<=>]?\\d+|m)?|\\sex)(?=:(?=\\s*set?\\s[^\\n:]+:)|:(?!\\s* set?\\s))
		(?:(?:\\s|\\s*:\\s*)\\w*(?:\\s*=(?:[^\\n\\\\\\s]|\\\\.)*)?)*[\\s:]
		(?:filetype|ft|syntax)\\s*=
			(?:vlang|v)
		(?=\\s|:|$)
	)
"""
patterns: [{
	# Interpreter directive
	name:  "comment.line.number-sign.hashbang.v"
	begin: "\\A#!"
	end:   "$"
	beginCaptures:
		0: name: "punctuation.definition.comment.v"
}, include: "#main"]

repository:
	main:
		patterns: [
			{include: "#comment"}
			{include: "#function"}
			{include: "#var"}
			
			# Fallback highlighting for unexpected tokens
			{include: "#expr"}
			{include: "#typeBuiltin"}
			{include: "#brackets"}
			{include: "#comma"}
		]


	# Anything that's accepted inside `fn foo(‚Ä¶)`; e.g., `mut names ...[]string`
	arg:
		name:  "meta.parameter.v"
		begin: "(?:(mut)\\s+)?(?!\\d|_\\b)(\\w+)\\b"
		end:   "(?!\\d|\\G)(?<=\\w)\\b|(?=\\s*(?!/[/*]|\\.{3})[^\\[\\w\\s])"
		beginCaptures:
			1: name: "storage.modifier.mutable.v"
			2: name: "variable.parameter.function.v"
		patterns: [
			{include: "#dots"}
			{include: "#types"}
		]


	# Argument list, surrounded by parentheses
	args:
		name:  "meta.arguments.v"
		begin: "\\("
		end:   "\\)"
		beginCaptures: 0: patterns: [include: "#brackets"]
		endCaptures:   0: patterns: [include: "#brackets"]
		patterns: [
			{include: "#comment"}
			{include: "#arg"}
			{include: "#comma"}
		]


	# Bracket characters
	brackets:
		patterns: [
			{match: "\\{", name: "punctuation.definition.bracket.curly.brace.begin.v"}
			{match: "\\}", name: "punctuation.definition.bracket.curly.brace.end.v"}
			{match: "\\[", name: "punctuation.definition.bracket.square.begin.v"}
			{match: "\\]", name: "punctuation.definition.bracket.square.end.v"}
			{match: "\\(", name: "punctuation.definition.bracket.round.parenthesis.begin.v"}
			{match: "\\)", name: "punctuation.definition.bracket.round.parenthesis.end.v"}
			{match: "<",   name: "punctuation.definition.bracket.angle.begin.v"}
			{match: ">",   name: "punctuation.definition.bracket.angle.end.v"}
		]


	# You know what this is
	comma:
		name: "punctuation.separator.delimiter.list.comma.v"
		match: ","


	# Comments, both single- and multi-line forms
	comment:
		patterns: [
			{include: "#commentLine"}
			{include: "#commentBlock"}
		]
	
	# Single-line comment
	commentLine:
		name:  "comment.line.double-slash.v"
		begin: "//"
		end:   "$"
		beginCaptures:
			0: name: "punctuation.definition.comment.v"

	# Multiline (nestable) comment
	commentBlock:
		name:  "comment.block.v"
		begin: "/\\*"
		end:   "\\*/"
		beginCaptures: 0: name: "punctuation.definition.comment.begin.v"
		endCaptures:   0: name: "punctuation.definition.comment.end.v"
		patterns: [include: "#commentBlock"]


	# Contiguous Full-stops/periods
	dots:
		patterns: [{
			# Ellipsis/‚Äúsplat‚Äù operator, used to implement variadic functions: `...rest`
			name: "keyword.operator.range.ellipsis.splat.spread.rest.dots.v"
			match: "\\.{3}"
		},{
			# Slice/range operator: `1..3`
			name:  "keyword.operator.slice.range.spread.dots.v"
			match: "(?<!\\.)\\.{2}(?!\\.)"
		}]


	# Expression (e.g., stuff matched after `:=`)
	expr:
		patterns: [
			{include: "#string"}
			{include: "#number"}
			{include: "#operators"}
			{include: "#exprGroup"}
			{include: "#variable"}
			{include: "#comment"}
		]

	# ((Bracketed) (expression))
	exprGroup:
		name:  "meta.expression.v"
		begin: "\\("
		end:   "\\)"
		beginCaptures: 0: patterns: [include: "#brackets"]
		endCaptures:   0: patterns: [include: "#brackets"]
		patterns: [include: "#expr"]


	# Function declaration
	function:
		name:  "meta.function.v"
		begin: "(?<![-$])\\b(?:(pub)\\s+)?(fn)(?=\\s|$|\\(|/[/*])"
		end:   "(?!\\G|(?={))"
		beginCaptures:
			1: name: "storage.modifier.public.v"
			2: name: "storage.type.function.v"
		patterns: [{
			name:  "meta.function-header.v"
			begin: "\\G"
			end:   "(?={)"
			patterns: [include: "#functionHeader"]
		},{
			name:  "meta.function-body.v"
			begin: "{"
			end:   "}"
			beginCaptures: 0: patterns: [include: "#brackets"]
			endCaptures:   0: patterns: [include: "#brackets"]
			patterns: [include: "#main"]
		}]


	# fn foo(arg type)
	functionHeader:
		patterns: [{
			# Skip empty lines
			begin: "\\G(?=[ \\t]*(?:$|/[/*]))"
			end:   "(?=\\S)(?!/[/*])"
			patterns: [include: "#comment"]
		},{
			# Receiver argument (for methods)
			name:  "meta.receiver.v"
			begin: "(?=\\()"
			end:   "(?<=\\))"
			patterns: [include: "#args"]
		},{
			# Function name
			begin: "\\w+"
			end:   "(?={)"
			beginCaptures:
				0: name: "entity.name.function.v"
			patterns: [{
				# Argument list
				name: "meta.parameters.v"
				begin: "(?=\\()"
				end:   "(?<=\\))"
				patterns: [include: "#args"]
			},{
				# Return type
				name:  "meta.return-type.v"
				begin: "(?<=\\))"
				end:   "(?={)|(?<=\\))(?!\\G)"
				patterns: [{
					# Multiple return values: fn foo() (first, second) {‚Ä¶}
					begin: "\\("
					end:   "\\)"
					beginCaptures: 0: patterns: [include: "#brackets"]
					endCaptures:   0: patterns: [include: "#brackets"]
					patterns: [include: "#types"]
				}, include: "#types"]
			}, include: "#comment"]
		}]
	
	
	# Identifier, including any adjoining subscripts: `struct.field`, `array[index]`
	ident:
		begin: "\\b(_)\\b|(?!\\d)(\\w+)"
		end:   "(?!/[/*])(?=[^\\s\\[.])"
		beginCaptures:
			1: name: "constant.language.ignored-value.v"
			2: name: "variable.other.v"
		patterns: [include: "#subscript"]
	
	
	# Access modifiers
	modifiers:
		patterns: [
			{match: "\\b(pub)\\b",       name: "storage.modifier.access.pub.public.v"}
			{match: "\\b(mut)\\b",       name: "storage.modifier.access.mut.mutable.v"}
			{match: "\\b(__global)\\b",  name: "storage.modifier.access.all.global.v"}
		]


	# All forms of numeric literals
	number:
		patterns: [
			{include: "#numberFloat"}
			{include: "#numberInt"}
		]
	
	# Floating-point
	numberFloat:
		name:  "constant.numeric.decimal.float.real.v"
		match: "\\b(?!_)[\\d_]+(?<!_)\\.\\d*|\\.\\d+"

	# Integers, signed or unsigned
	numberInt:
		patterns: [
			{match: "\\b0x(?!_)[0-9A-F_a-f]+(?<!_)\\b", name: "constant.numeric.integer.hexadecimal.int.hex.v"}
			{match: "\\b0o(?!_)[0-7_]+(?<!_)\\b",       name: "constant.numeric.integer.octal.int.oct.v"}
			{match: "\\b0b(?!_)[0-1_]+(?<!_)\\b",       name: "constant.numeric.integer.binary.int.bin.v"}
			{match: "\\b(?!_)[0-9_]+(?<!_)\\b",         name: "constant.numeric.integer.decimal.int.dec.v"}
		]


	# Non-alphanumeric operators
	operators:
		patterns: [
			{include: "#operatorsExpr"}
			{include: "#operatorsAssignment"}
		]

	# Operators used for declaring or reassigning a variable
	operatorsAssignment:
		patterns: [
			{match: "(?:<<|>>|[&|^])=", name: "keyword.operator.assignment.compound.bitwise.v"}
			{match: "[-+*/%]=",         name: "keyword.operator.assignment.compound.v"}
			{match: ":=",               name: "keyword.operator.assignment.declaration.v"}
			{match: "(?<!=)=(?!=)",     name: "keyword.operator.assignment.mutation.v"}
		]

	# Operators accepted as part of an expression
	operatorsExpr:
		patterns: [
			{match: "!=|==",   name: "keyword.operator.logical.comparison.v"}
			{match: "\\|\\|",  name: "keyword.operator.logical.boolean.or.v"}
			{match: "&&",      name: "keyword.operator.logical.boolean.and.v"}
			{match: "!!",      name: "keyword.operator.logical.boolean.cast.v"}
			{match: "!",       name: "keyword.operator.logical.boolean.not.v"}
			{match: "<<|>>",   name: "keyword.operator.bitwise.shift.v"}
			{match: "[~&|^]",  name: "keyword.operator.bitwise.v"}
			{include: "#operatorsMath"}
		]
	
	# Usual BODMAS fauna: + - * / %
	operatorsMath:
		name: "keyword.operator.arithmetic.v"
		match: "(?!/[/*])[-+*/%](?!=)"
	

	# "Quoted string" or rune (character literal)
	string:
		patterns: [{
			# r'Raw\nstring'
			name:  "string.quoted.single.raw.v"
			begin: "(r)(')"
			end:   "'"
			beginCaptures:
				1: name: "keyword.operator.raw-string.v"
				2: name: "punctuation.definition.string.begin.v"
			endCaptures:
				0: name: "punctuation.definition.string.end.v"
		},{
			# r"Raw\nstring"
			name:  "string.quoted.double.raw.v"
			begin: '(r)(")'
			end:   '"'
			beginCaptures:
				1: name: "keyword.operator.raw-string.v"
				2: name: "punctuation.definition.string.begin.v"
			endCaptures:
				0: name: "punctuation.definition.string.end.v"
		},{
			# 'Single-quoted'
			name:  "string.quoted.single.v"
			begin: "'"
			end:   "'"
			beginCaptures: 0: name: "punctuation.definition.string.begin.v"
			endCaptures:   0: name: "punctuation.definition.string.end.v"
			patterns: [include: "#stringInnards"]
		},{
			# "Double-quoted"
			name:  "string.quoted.double.v"
			begin: '"'
			end:   '"'
			beginCaptures: 0: name: "punctuation.definition.string.begin.v"
			endCaptures:   0: name: "punctuation.definition.string.end.v"
			patterns: [include: "#stringInnards"]
		},{
			# Rune: `üòÇ`
			name:  "string.quoted.single.rune.v"
			begin: "`"
			end:   "`"
			beginCaptures: 0: name: "punctuation.definition.string.begin.v"
			endCaptures:   0: name: "punctuation.definition.string.end.v"
		}]

	# Patterns matched inside a non-raw (cooked?) string
	stringInnards:
		patterns: [
			{include: "#escape"}
			{include: "#stringInterpolation"}
		]


	# Variable interpolation: "$foo ${bar}"
	stringInterpolation:
		patterns: [{
			# Unbracketed: "$foo $struct.field"
			name:  "meta.interpolation.simple.v"
			match: "(\\$)(\\w+(?:\\.\\w+)*)"
			captures:
				1: name: "punctuation.definition.variable.v"
				2: patterns: [
					{include: "#variable"}
					{include: "#subscript"}
				]
		},{
			# Bracketed: "${foo.bar > 32}"
			name:  "meta.embedded.section.interpolation.complex.v"
			begin: "\\${"
			end:   "}"
			beginCaptures: 0: name: "punctuation.section.embedded.begin.v"
			endCaptures:   0: name: "punctuation.section.embedded.end.v"
			patterns: [
				{include: "#expr"}
				{include: "#main"}
			]
		}]
	
	
	# Item access, which may span multiple lines (hence the begin/end blocks)
	subscript:
		patterns: [{
			# Array-like access: foo[1], bar[0][1..3]
			name:  "meta.subscript.member-access.indexed.v"
			begin: "\\["
			end:   "\\]"
			beginCaptures: 0: patterns: [include: "#brackets"]
			endCaptures:   0: patterns: [include: "#brackets"]
			patterns: [include: "#expr"]
		},{
			# Struct field access: foo.bar, foo.bar.baz
			name:  "meta.subscript.member-access.named.v"
			begin: "(?<!\\.)\\.(?!\\.)"
			end:   "\\w+|(?!/[/*])(?=[^\\w\\s\\[.])"
			beginCaptures: 0: name: "punctuation.separator.member.accessor.dot.period.v"
			endCaptures:   0: name: "variable.other.property.v"
			patterns: [include: "#comment"]
		}, include: "#comment"]


	# Escaped string characters
	escape:
		patterns: [
			{include: "#escapedCharacter"}
			{include: "#escapedNewline"}
		]

	# C-like escape sequences
	escapedCharacter:
		patterns: [{
			# C-like, single-character escapes
			name: "constant.character.escape.v"
			match: "(\\\\)[abefnrtv'\"?\\\\]"
			captures:
				1: name: "punctuation.definition.escape.v"
		},{
			# Codepoint, octal
			name:  "constant.character.escape.codepoint.octal.oct.v"
			match: "(\\\\)[0-7]{3}"
			captures:
				1: name: "punctuation.definition.escape.v"
		},{
			# Codepoint, hexadecimal
			name:  "constant.character.escape.codepoint.hexadecimal.hex.v"
			match: "\\\\(?:x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})"
			captures: 0: patterns: [{
				name: "punctuation.definition.escape.v"
				match: "\\\\[xuU]"
			}]
		},{
			# Unrecognised escape sequence
			name:  "constant.character.escape.other.unknown.v"
			match: "(\\\\)."
			captures:
				1: name: "punctuation.definition.escape.v"
		}]
	
	
	# Line continuation
	escapedNewline:
		name:  "constant.character.escape.newline.line-continuation.v"
		begin: "(\\\\)$\\s*+"
		end:   "^"
		beginCaptures:
			1: name: "punctuation.definition.escape.v"



	# Type name, sans access modifiers or array indicators
	type:
		patterns: [
			{include: "#typeBuiltin"}
			{include: "#typeUser"}
		]

	# Predefined/built-in types
	typeBuiltin:
		name: "support.type.${1:/downcase}.v"
		match: "(?x) \\b
			( any
			| any_float
			| any_int
			| bool
			| byte
			| byteptr
			| charptr
			| f(?:32|64)
			| [iu](?:8|16|32|64|128)
			| int
			| rune
			| size_t
			| string
			| voidptr
			) \\b"			

	# User-defined/unknown type
	typeUser:
		name: "entity.name.type.v"
		match: "(?!\\d)(\\w+)"


	# Anywhere type annotations are expected/legal
	types:
		patterns: [
			{include: "#comment"}
			{include: "#type"}
			{include: "#comma"}
			
			# Array indicator: `list []string`, `table [][]string`
			name: "punctuation.definition.array-type.v"
			match: "\\[\\]"
			captures:
				0: patterns: [include: "#brackets"]
		]


	# Variable declaration or assignment
	var:
		patterns: [
			{include: "#varPubMut"}
			{include: "#varGlobal"}
			{include: "#varMut"}
			{include: "#varPub"}
			{include: "#varDecl"}
			{include: "#varAssign"}
		]
	
	# Variable assignment, legal or not
	varAssign:
		patterns: [{
			# `name = value`, `name += value`
			name:  "meta.variable.assignment.v"
			begin: "\\b(?!pub|mut)(?=\\w+\\s*(?:<<|>>|[-+*/%&|^])?=)"
			end:   "(?!\\G)"
			patterns: [
				{include: "#varLHS"}
				{include: "#varRHS"}
			]
		},{
			# Incomplete assignment statement; included for the same reasons
			# outlined below (see comment in ‚Äú#varDecl‚Äù rule's last pattern).
			begin: "(?=(?:<<|>>|[-+*/%&|^])?=)"
			end:   "(?!\\G)"
			patterns: [include: "#varRHS"]
		}]
		
	# Private, immutable Variable declaration (default)
	varDecl:
		patterns: [{
			# `name := value`
			name:  "meta.variable.declaration.v"
			begin: "\\b(?!pub|mut)(?=\\w+\\s*:=)"
			end:   "(?!\\G)"
			patterns: [
				{include: "#varLHS"}
				{include: "#varRHS"}
			]
		},{
			# XXX: Incomplete declaration statement. Included to improve our
			# chances of correctly highlighting weird (but legal) constructs
			# (e.g., `name /*‚Ä¶ \n ‚Ä¶*/ := value`)
			begin: "(?=:=)"
			end:   "(?!\\G)"
			patterns: [include: "#varRHS"]
		}]
	
	# Global variable: `__global name := value`
	varGlobal:
		name:  "meta.variable.declaration.global.v"
		begin: "\\b(__global)(?=\\s|$|/[/*])"
		end:   "(?!\\G)"
		beginCaptures:
			1: patterns: [include: "#modifiers"]
		patterns: [
			{include: "#varLHS"}
			{include: "#varRHS"}
		]
	
	# Public, mutable variable declaration: `pub mut name := value`
	#
	# NB: This won't match `pub \n mut` due to limitations of TextMate.
	# Instead, ‚Äú#varPub‚Äù is written to accommodate an unexpected `mut`.
	varPubMut:
		name:  "meta.variable.declaration.public.mutable.v"
		begin: "\\b(pub\\s+mut)(?=\\s|$|/[/*])"
		end:   "(?!\\G)"
		beginCaptures:
			1: patterns: [include: "#modifiers"]
		patterns: [
			{include: "#varLHS"}
			{include: "#varRHS"}
		]

	# Private, mutable variable declaration: `mut name := value`
	varMut:
		name:  "meta.variable.declaration.mutable.v"
		begin: "\\b(mut)(?=\\s|$|/[/*])"
		end:   "(?!\\G)"
		beginCaptures:
			1: patterns: [include: "#modifiers"]
		patterns: [
			{include: "#varLHS"}
			{include: "#varRHS"}
		]

	# Public, immutable variable declaration: `pub name := value`
	#
	# NOTE: This rule also covers `pub \n mut name := value`,
	# which is impossible to match short of a begin/end pair.
	varPub:
		name:  "meta.variable.declaration.public.v"
		begin: "\\b(pub)(?=\\s|$|/[/*])"
		end:   "(?!\\G)"
		beginCaptures:
			1: patterns: [include: "#modifiers"]
		patterns: [
			{include: "#varLHS"}
			{include: "#varRHS"}
		]
	
	# Left-hand side of a variable declaration/assignment
	varLHS:
		name:  "meta.lhs.v"
		begin: "\\G"
		end:   "(?=\\s*(?:<<|>>|[-+*/%&|^:])?=)"
		patterns: [{
			# Skip lines that're blank or contain only comments, ignoring
			# a stray `mut` that might be left from `pub \n mut ‚Ä¶`
			begin: "\\G(?=(?:[ \\t]*\\bmut\\b)?[ \\t]*(?:$|/[/*]))"
			end:   "(?=\\w)(?!\\bmut\\b)"
			patterns: [
				{include: "#modifiers"}
				{include: "#comment"}
			]
		},{
			begin: "\\w+"
			end:   "(?=[^\\[\\s.])(?!/[/*])"
			beginCaptures:
				0: name: "variable.assignment.v"
			patterns: [
				{include: "#subscript"}
				{include: "#comment"}
			]
		}, include: "#comment"]
	
	# Right-hand side of a variable declaration/assignment
	varRHS:
		contentName: "meta.rhs.v"
		begin: "[ \\t]*((?:<<|>>|[-+*/%&|^:])?=)"
		end:   "(?!\\G)"
		beginCaptures:
			1: patterns: [include: "#operatorsAssignment"]
		patterns: [{
			# Skip past empty or comment-only lines
			begin: "\\G[ \\t]*(?=$|/[/*])"
			end:   "(?=\\S)(?!/[/*])"
			patterns: [include: "#expr"]
		},{
			begin: "\\G[ \\t]*(?=[^\\s\\(])(?!/[/*])"
			end:   "$|(?=[}\\]\\),])"
			patterns: [include: "#expr"]
		}, include: "#expr"]
